From 8f19af61627d196b09509b654e39e12d4900038d Mon Sep 17 00:00:00 2001
From: dolanzhao <neuzqd@gmail.com>
Date: Mon, 18 Jan 2021 23:12:05 -0500
Subject: [PATCH] attach patch

---
 core/CMakeLists.txt      |  27 ++
 core/dispatch.c          |  12 +-
 core/dynamo.c            |  15 +
 core/globals.h           |   2 +
 core/heap.c              |   7 +-
 core/lib/dr_app.h        |   3 +
 core/lib/drcct_attach.h  |  22 +
 core/synch.c             | 234 +++++++++-
 core/unix/drcct_attach.c | 940 +++++++++++++++++++++++++++++++++++++++
 core/unix/loader.c       |   1 +
 core/unix/signal.c       |   3 +
 tools/CMakeLists.txt     |   4 +
 tools/drcctprof.c        | 622 ++++++++++++++++++++++++++
 13 files changed, 1883 insertions(+), 9 deletions(-)
 create mode 100644 core/lib/drcct_attach.h
 create mode 100644 core/unix/drcct_attach.c
 create mode 100644 tools/drcctprof.c

diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
index 3bcf74ff..bf35f1ea 100644
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -1026,6 +1026,28 @@ if (WIN32)
     "${EXECUTABLE_OUTPUT_DIRECTORY}/" VERBATIM)
 endif (WIN32)
 
+###########################################################################
+# DrCCTAttach library
+if (UNIX)
+  set(DRCCTATTACH_SRCS
+    unix/drcct_attach.c
+    config.c    # to read config
+    string.c
+    io.c
+    )
+
+  add_library(drcctattachlib STATIC ${DRCCTATTACH_SRCS})
+  add_dependencies(drcctattachlib generate_syslog)
+
+  # We need our own memcpy + memset to avoid glibc versioning (i#1504).
+  target_link_libraries(drcctattachlib drdecode drlibc)
+  target_link_libraries(drcctattachlib drmemfuncs)
+  target_link_libraries(drcctattachlib unwind-ptrace unwind-generic unwind)
+
+  set_target_properties(drcctattachlib PROPERTIES
+    COMPILE_DEFINITIONS "NOT_DYNAMORIO_CORE_PROPER")
+endif ()
+
 ###########################################################################
 # Annotations
 
@@ -1183,3 +1205,8 @@ if (UNIX)
   DR_export_target(drmemfuncs)
   install_exported_target(drmemfuncs ${INSTALL_LIB_BASE})
 endif ()
+
+if (UNIX)
+  install_exported_target(drcctattachlib ${INSTALL_LIB_BASE})
+  DR_export_target(drcctattachlib)
+endif (UNIX)
\ No newline at end of file
diff --git a/core/dispatch.c b/core/dispatch.c
index d93a01d2..59c1b0db 100644
--- a/core/dispatch.c
+++ b/core/dispatch.c
@@ -633,12 +633,12 @@ dispatch_at_stopping_point(dcontext_t *dcontext)
 
         /* XXX i#95: should we add an instrument_thread_detach_event()? */
 
-#    ifdef DR_APP_EXPORTS
-    /* not_under will be called by dynamo_shared_exit so skip it here. */
-    if (dcontext->next_tag != (app_pc)dr_app_stop_and_cleanup &&
-        dcontext->next_tag != (app_pc)dr_app_stop_and_cleanup_with_stats)
-#    endif
-        dynamo_thread_not_under_dynamo(dcontext);
+// #    ifdef DR_APP_EXPORTS
+//     /* not_under will be called by dynamo_shared_exit so skip it here. */
+//     if (dcontext->next_tag != (app_pc)dr_app_stop_and_cleanup &&
+//         dcontext->next_tag != (app_pc)dr_app_stop_and_cleanup_with_stats)
+// #    endif
+//         dynamo_thread_not_under_dynamo(dcontext);
     dcontext->go_native = false;
 }
 #endif
diff --git a/core/dynamo.c b/core/dynamo.c
index a5969918..cfae903e 100644
--- a/core/dynamo.c
+++ b/core/dynamo.c
@@ -382,6 +382,14 @@ get_dr_stats(void)
     return d_r_stats;
 }
 
+/* patch for ptrace inject*/
+DYNAMORIO_EXPORT void
+dynamorio_app_pre_init(void)
+{
+    standalone_library = false;
+    standalone_init_count = 0;
+}
+
 /* initialize per-process dynamo state; this must be called before any
  * threads are created and before any other API calls are made;
  * returns zero on success, non-zero on failure
@@ -2871,6 +2879,13 @@ dr_app_setup_and_start(void)
         dr_app_start();
     return r;
 }
+
+/* patch for ptrace inject*/
+DR_APP_API void
+dynamorio_back_to_native(void *dcontext)
+{
+    ((dcontext_t *)dcontext)->go_native = true;
+}
 #endif
 
 /* For use by threads that start and stop whether dynamo controls them.
diff --git a/core/globals.h b/core/globals.h
index a0e1d613..8e46d475 100644
--- a/core/globals.h
+++ b/core/globals.h
@@ -610,6 +610,8 @@ extern bool dr_api_exit;
 #define ALL_THREADS_HASH_BITS 12
 extern thread_record_t **all_threads;
 extern mutex_t all_threads_lock;
+DYNAMORIO_EXPORT void
+dynamorio_app_pre_init(void);
 DYNAMORIO_EXPORT int
 dynamorio_app_init(void);
 int
diff --git a/core/heap.c b/core/heap.c
index 62ce43e3..e4c66654 100644
--- a/core/heap.c
+++ b/core/heap.c
@@ -1078,9 +1078,11 @@ vmm_heap_unit_exit(vm_heap_t *vmh)
         DODEBUG({
             byte *sp;
             GET_STACK_PTR(sp);
-            ASSERT(!(sp >= vmh->start_addr && sp < vmh->end_addr));
+            // ASSERT(!(sp >= vmh->start_addr && sp < vmh->end_addr));
         });
         free_heap = true;
+        if (d_r_strcmp(vmh->name, "vmheap") == 0)
+            free_heap = false;
     }
 #endif
     if (free_heap) {
@@ -1949,7 +1951,8 @@ vmh_exit(vm_heap_t *vmh, bool contains_stacks)
          * left behind all TPCs needed so then we can assert even for
          * detach.
          */
-        ASSERT(IF_WINDOWS(doing_detach ||) /* not deterministic when detaching */
+        // ASSERT(IF_WINDOWS(doing_detach ||) /* not deterministic when detaching */
+        ASSERT(doing_detach ||
                    vmh->num_free_blocks == vmh->num_blocks - unfreed_blocks ||
                /* >=, not ==, b/c if we hit the vmm limit the cur dstack
                 * could be outside of vmm (i#1164).
diff --git a/core/lib/dr_app.h b/core/lib/dr_app.h
index 675b261f..f52cd8b0 100644
--- a/core/lib/dr_app.h
+++ b/core/lib/dr_app.h
@@ -165,6 +165,9 @@ dr_app_running_under_dynamorio(void);
  */
 DR_APP_API void *
 dr_app_handle_mbr_target(void *target);
+
+DR_APP_API void
+dynamorio_back_to_native(void *dcontext);
 #endif /* LINUX */
 
 #endif /* _DR_APP_H_ */
diff --git a/core/lib/drcct_attach.h b/core/lib/drcct_attach.h
new file mode 100644
index 00000000..23cae804
--- /dev/null
+++ b/core/lib/drcct_attach.h
@@ -0,0 +1,22 @@
+/* 
+ *  Copyright (c) 2020-2021 Xuhpclab. All rights reserved.
+ *  Licensed under the MIT License.
+ *  See LICENSE file for more information.
+ */
+
+#ifndef _DRCCTPROF_ATTACH_H_
+#define _DRCCTPROF_ATTACH_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+DR_EXPORT
+bool
+drcct_attach_inject_ptrace(pid_t pid, const char *appname, bool verbose_on);
+
+DR_EXPORT
+bool
+drcct_detach_inject_ptrace(pid_t pid, bool verbose_on);
+
+#endif /* _DR_INJECT_H_ */
diff --git a/core/synch.c b/core/synch.c
index 65c5c738..41b6a202 100644
--- a/core/synch.c
+++ b/core/synch.c
@@ -2091,7 +2091,8 @@ detach_on_permanent_stack(bool internal, bool do_cleanup, dr_stats_t *drstats)
 #endif
 
     /* suspend all DR-controlled threads at safe locations */
-    if (!synch_with_all_threads(THREAD_SYNCH_SUSPENDED_VALID_MCONTEXT, &threads,
+    // if (!synch_with_all_threads(THREAD_SYNCH_SUSPENDED_VALID_MCONTEXT, &threads,
+    if (!synch_with_all_threads(THREAD_SYNCH_SUSPENDED, &threads,
                                 &num_threads,
                                 /* Case 6821: allow other synch-all-thread uses
                                  * that beat us to not wait on us. We still have
@@ -2302,4 +2303,235 @@ detach_on_permanent_stack(bool internal, bool do_cleanup, dr_stats_t *drstats)
     SELF_PROTECT_DATASEC(DATASEC_RARELY_PROT);
     dynamo_detaching_flag = LOCK_FREE_STATE;
     EXITING_DR();
+    dynamorio_syscall(62, 2, get_process_id(), SIGTRAP);
 }
+
+// void
+// detach_on_permanent_stack_test()
+// {
+//     dcontext_t *my_dcontext;
+//     thread_record_t **threads;
+//     thread_record_t *my_tr = NULL;
+//     int i, num_threads, my_idx = -1;
+//     thread_id_t my_id;
+//     DEBUG_DECLARE(bool ok;)
+//     DEBUG_DECLARE(int exit_res;)
+
+//     /* synch-all flags: */
+//     uint flags = 0;
+//     /* For Unix, such privilege problems are rarer but we would still prefer to
+//      * continue if we hit a problem.
+//      */
+//     flags |= THREAD_SYNCH_SUSPEND_FAILURE_IGNORE;
+
+//     /* i#297: we only synch client threads after process exit event. */
+//     flags |= THREAD_SYNCH_SKIP_CLIENT_THREAD;
+
+//     ENTERING_DR();
+
+//     /* dynamo_detaching_flag is not really a lock, and since no one ever waits
+//      * on it we can't deadlock on it either.
+//      */
+//     if (!atomic_compare_exchange(&dynamo_detaching_flag, LOCK_FREE_STATE, LOCK_SET_STATE))
+//         return;
+
+//     /* Unprotect .data for exit cleanup.
+//      * XXX: more secure to not do this until we've synched, but then need
+//      * alternative prot for started_detach and init_apc_go_native*
+//      */
+//     SELF_UNPROTECT_DATASEC(DATASEC_RARELY_PROT);
+
+//     ASSERT(!started_detach);
+//     started_detach = true;
+
+//     ASSERT(dynamo_initialized);
+//     ASSERT(!dynamo_exited);
+
+//     my_id = d_r_get_thread_id();
+//     my_dcontext = get_thread_private_dcontext();
+//     if (my_dcontext == NULL) {
+//         /* We support detach after just dr_app_setup() with no start. */
+//         ASSERT(!dynamo_started);
+//         my_tr = thread_lookup(my_id);
+//         ASSERT(my_tr != NULL);
+//         my_dcontext = my_tr->dcontext;
+//         os_process_under_dynamorio_initiate(my_dcontext);
+//         os_process_under_dynamorio_complete(my_dcontext);
+//         dynamo_thread_under_dynamo(my_dcontext);
+//         ASSERT(get_thread_private_dcontext() == my_dcontext);
+//     }
+//     ASSERT(my_dcontext != NULL);
+
+//     LOG(GLOBAL, LOG_ALL, 1, "Detach: thread %d starting detach process\n", my_id);
+//     SYSLOG(SYSLOG_INFORMATION, INFO_DETACHING, 2, get_application_name(),
+//            get_application_pid());
+
+//     /* synch with flush */
+//     if (my_dcontext != NULL)
+//         enter_threadexit(my_dcontext);
+
+//     SYSLOG_INTERNAL_INFO("Detaching from process, get_list_of_threads finish");
+//     /* suspend all DR-controlled threads at safe locations */
+//     if (!synch_with_all_threads(THREAD_SYNCH_SUSPENDED, &threads,
+//                                 &num_threads,
+//                                 /* Case 6821: allow other synch-all-thread uses
+//                                  * that beat us to not wait on us. We still have
+//                                  * a problem if we go first since we must xfer
+//                                  * other threads.
+//                                  */
+//                                 THREAD_SYNCH_NO_LOCKS_NO_XFER, flags)) {
+//         REPORT_FATAL_ERROR_AND_EXIT(FAILED_TO_SYNCHRONIZE_THREADS, 2,
+//                                     get_application_name(), get_application_pid());
+//     }
+
+//     /* Now we own the thread_initexit_lock.  We'll release the locks grabbed in
+//      * synch_with_all_threads below after cleaning up all the threads in case we
+//      * need to grab it during process exit cleanup.
+//      */
+//     ASSERT(mutex_testlock(&all_threads_synch_lock) &&
+//            mutex_testlock(&thread_initexit_lock));
+
+//     ASSERT(!doing_detach);
+//     doing_detach = true;
+
+// #ifdef HOT_PATCHING_INTERFACE
+//     /* In hotp_only mode, we must remove patches when detaching; we don't want
+//      * to leave in all our hooks and detach; that will definitely crash the app.
+//      */
+//     if (DYNAMO_OPTION(hotp_only))
+//         hotp_only_detach_helper();
+// #endif
+
+//     if (!DYNAMO_OPTION(thin_client))
+//         revert_memory_regions();
+//     unhook_vsyscall();
+//     LOG(GLOBAL, LOG_ALL, 1,
+//         "Detach : unpatched ntdll.dll and fixed memory permissions\n");
+
+//     /* perform exit tasks that require full thread data structs */
+//     dynamo_process_exit_with_thread_info();
+
+//     LOG(GLOBAL, LOG_ALL, 1, "Detach: starting to translate contexts\n");
+//     for (i = 0; i < num_threads; i++) {
+//         priv_mcontext_t mc;
+//         if (threads[i]->dcontext == my_dcontext) {
+//             my_idx = i;
+//             my_tr = threads[i];
+//             continue;
+//         } else if (IS_CLIENT_THREAD(threads[i]->dcontext)) {
+//             /* i#297 we will kill client-owned threads later after app exit events
+//              * in dynamo_shared_exit().
+//              */
+//             continue;
+//         } else if (detach_do_not_translate(threads[i])) {
+//             LOG(GLOBAL, LOG_ALL, 2, "Detach: not translating " TIDFMT "\n",
+//                 threads[i]->id);
+//         } else {
+//             LOG(GLOBAL, LOG_ALL, 2, "Detach: translating " TIDFMT "\n", threads[i]->id);
+//             DEBUG_DECLARE(ok =)
+//             thread_get_mcontext(threads[i], &mc);
+//             ASSERT(ok);
+//             /* For a thread at a syscall, we use SA_RESTART for our suspend signal,
+//              * so the kernel will adjust the restart point back to the syscall for us
+//              * where expected.  This is an artifical signal we're introducing, so an
+//              * app that assumes no signals and assumes its non-auto-restart syscalls
+//              * don't need loops could be broken.
+//              */
+//             LOG(GLOBAL, LOG_ALL, 3,
+//                 /* Having the code bytes can help diagnose post-detach where the code
+//                  * cache is gone.
+//                  */
+//                 "Detach: pre-xl8 pc=%p (%02x %02x %02x %02x %02x), xsp=%p "
+//                 "for thread " TIDFMT "\n",
+//                 mc.pc, *mc.pc, *(mc.pc + 1), *(mc.pc + 2), *(mc.pc + 3), *(mc.pc + 4),
+//                 mc.xsp, threads[i]->id);
+//             DEBUG_DECLARE(ok =)
+//             translate_mcontext(threads[i], &mc, true /*restore mem*/, NULL /*f*/);
+//             ASSERT(ok);
+
+//             if (!threads[i]->under_dynamo_control) {
+//                 LOG(GLOBAL, LOG_ALL, 1,
+//                     "Detach : thread " TIDFMT " already running natively\n",
+//                     threads[i]->id);
+//                 /* we do need to restore the app ret addr, for native_exec */
+//                 if (!DYNAMO_OPTION(thin_client) && DYNAMO_OPTION(native_exec) &&
+//                     !vmvector_empty(native_exec_areas)) {
+//                     put_back_native_retaddrs(threads[i]->dcontext);
+//                 }
+//             }
+//             detach_finalize_translation(threads[i], &mc);
+
+//             LOG(GLOBAL, LOG_ALL, 1, "Detach: pc=" PFX " for thread " TIDFMT "\n", mc.pc,
+//                 threads[i]->id);
+//             ASSERT(!is_dynamo_address(mc.pc) && !in_fcache(mc.pc));
+//             /* XXX case 7457: if the thread is suspended after it received a fault
+//              * but before the kernel copied the faulting context to the user mode
+//              * structures for the handler, it could result in a codemod exception
+//              * that wouldn't happen natively!
+//              */
+//             DEBUG_DECLARE(ok =)
+//             thread_set_mcontext(threads[i], &mc);
+//             ASSERT(ok);
+//         }
+//         /* Resumes the thread, which will do kernel-visible cleanup of
+//          * signal state. Resume happens within the synch_all region where
+//          * the thread_initexit_lock is held so that we can clean up thread
+//          * data later.
+//          */
+//         os_signal_thread_detach(threads[i]->dcontext);
+//         LOG(GLOBAL, LOG_ALL, 1, "Detach: thread " TIDFMT " is being resumed as native\n",
+//             threads[i]->id);
+//         os_thread_resume(threads[i]);
+//     }
+
+//     ASSERT(my_idx != -1);
+
+//     LOG(GLOBAL, LOG_ALL, 1, "Detach: waiting for threads to fully detach\n");
+//     for (i = 0; i < num_threads; i++) {
+//         if (i != my_idx && !IS_CLIENT_THREAD(threads[i]->dcontext))
+//             os_wait_thread_detached(threads[i]->dcontext);
+//     }
+
+//     /* Clean up each thread now that everyone has gone native. Needs to be
+//      * done with the thread_initexit_lock held, which is true within a synched
+//      * region.
+//      */
+//     for (i = 0; i < num_threads; i++) {
+//         if (i != my_idx && !IS_CLIENT_THREAD(threads[i]->dcontext)) {
+//             LOG(GLOBAL, LOG_ALL, 1, "Detach: cleaning up thread " TIDFMT " %s\n",
+//                 threads[i]->id, "");
+//             dynamo_other_thread_exit(threads[i]);
+//         }
+//     }
+
+//     if (my_idx != -1) {
+//         /* pre-client thread cleanup (PR 536058) */
+//         dynamo_thread_exit_pre_client(my_dcontext, my_tr->id);
+//     }
+
+//     LOG(GLOBAL, LOG_ALL, 1, "Detach: Letting slave threads go native\n");
+//     end_synch_with_all_threads(threads, num_threads, false /*don't resume */);
+//     threads = NULL;
+
+//     LOG(GLOBAL, LOG_ALL, 1, "Detach: Entering final cleanup and unload\n");
+//     SYSLOG_INTERNAL_INFO("Detaching from process, entering final cleanup");
+
+//     DEBUG_DECLARE(exit_res =)
+//     dynamo_shared_exit(my_tr);
+//     SYSLOG_INTERNAL_INFO("dynamo_shared_exit finish");
+//     ASSERT(exit_res == SUCCESS);
+//     detach_finalize_cleanup();
+//     SYSLOG_INTERNAL_INFO("detach_finalize_cleanup finish");
+//     stack_free(d_r_initstack, DYNAMORIO_STACK_SIZE);
+
+//     dynamo_exit_post_detach();
+
+//     doing_detach = false;
+//     started_detach = false;
+
+//     SELF_PROTECT_DATASEC(DATASEC_RARELY_PROT);
+//     dynamo_detaching_flag = LOCK_FREE_STATE;
+//     EXITING_DR();
+//     SYSLOG_INTERNAL_INFO("EXITING_DR finish");
+//     dynamorio_syscall(62, 2, get_process_id(), SIGTRAP);
+// }
diff --git a/core/unix/drcct_attach.c b/core/unix/drcct_attach.c
new file mode 100644
index 00000000..be9dcd9c
--- /dev/null
+++ b/core/unix/drcct_attach.c
@@ -0,0 +1,940 @@
+/*
+ *  Copyright (c) 2020-2021 Xuhpclab. All rights reserved.
+ *  Licensed under the MIT License.
+ *  See LICENSE file for more information.
+ */
+
+#include "configure.h"
+#include "globals_shared.h"
+#include "../config.h" /* for get_config_val_other_app */
+#include "../globals.h"
+#ifdef LINUX
+#    include "include/syscall.h" /* for SYS_ptrace */
+#else
+#    include <sys/syscall.h>
+#endif
+#include "instrument.h"
+#include "instr.h"
+#include "instr_create.h"
+#include "decode.h"
+#include "disassemble.h"
+#include "os_private.h"
+#include "module.h"
+#include "module_private.h"
+#include "drcct_attach.h"
+
+#include <assert.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h> /* for strerror */
+#include <sys/mman.h>
+#include <sys/ptrace.h>
+#if defined(LINUX) && defined(AARCH64)
+#    include <linux/ptrace.h> /* for struct user_pt_regs */
+#endif
+#include <sys/uio.h> /* for struct iovec */
+#include <sys/user.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+#include <libunwind.h>
+#include <libunwind-ptrace.h>
+
+#define APP instrlist_append
+
+#ifdef DR_HOST_X86
+#    define USER_REGS_TYPE user_regs_struct
+#    define REG_PC_FIELD IF_X64_ELSE(rip, eip)
+#    define REG_SP_FIELD IF_X64_ELSE(rsp, esp)
+#    define REG_RETVAL_FIELD IF_X64_ELSE(rax, eax)
+#elif defined(DR_HOST_AARCH64)
+#    define USER_REGS_TYPE user_pt_regs
+#    define REG_PC_FIELD pc
+#    define REG_SP_FIELD sp
+#    define REG_RETVAL_FIELD regs[0] /* x0 in user_regs_struct */
+#endif
+
+static bool verbose = false;
+
+enum { MAX_SHELL_CODE = 4096 };
+enum { REG_PC_OFFSET = offsetof(struct USER_REGS_TYPE, REG_PC_FIELD) };
+
+static file_t injector_dr_fd;
+static file_t injectee_dr_fd;
+static pid_t injectee_pid;
+
+typedef struct _enum_name_pair_t {
+    const int enum_val;
+    const char *const enum_name;
+} enum_name_pair_t;
+
+
+static uint64_t
+hexadecimal_char_to_uint64(char* hex, int size){
+    uint64_t result = 0;
+    uint64_t pow_result = 1;
+    for(int i = size - 1; i >= 0; i--) {
+        int temp = 0;
+        if(hex[i] <= '9' && hex[i] >= '0') {
+            temp = hex[i] - '0';
+        }
+        if (hex[i] <= 'f' && hex[i] >= 'a') {
+            temp = hex[i] - 'a' + 10;
+        }
+        result += pow_result * temp;
+        pow_result *= 16;
+    }
+    return result;
+}
+
+static app_pc
+read_dr_app_stop_and_clean_pc(pid_t pid) {
+    char attach_config_name[MAXIMUM_PATH] = "";
+    sprintf(attach_config_name + strlen(attach_config_name), "/home/dolanwm/.dynamorio/drcctprof.attach.%d", pid);
+    
+    file_t attach_config_file =
+        os_open(attach_config_name, OS_OPEN_READ);
+    ASSERT(attach_config_file != INVALID_FILE);
+    char buff[19];
+    ssize_t buff_size = os_read(attach_config_file, buff, 18);
+    os_close(attach_config_file);
+    
+    if (buff_size < (ssize_t)18){
+        fprintf(stderr, "get \"drcctlib_detach\" failed buff_size = %ld\n", buff_size);
+        ASSERT(false);
+    }
+    buff[18] = '\0';
+    app_pc result = (app_pc)(void*)hexadecimal_char_to_uint64(buff+2, 16);
+    if (verbose) {
+        fprintf(stderr, "drcctlib_detach: (str)%s (p)%p\n", buff, (void*)result);
+    }
+    return result;
+}
+
+static void
+delete_last_attach_config(pid_t pid) {
+    char attach_config_name[MAXIMUM_PATH] = "";
+    sprintf(attach_config_name + strlen(attach_config_name), "/home/dolanwm/.dynamorio/drcctprof.attach.%d", pid);
+    if(os_file_exists(attach_config_name, false)) {
+        os_delete_file(attach_config_name);
+    }
+}
+
+/* Ptrace request enum name mapping.  The complete enumeration is in
+ * sys/ptrace.h.
+ */
+static const enum_name_pair_t pt_req_map[] = { { PTRACE_TRACEME, "PTRACE_TRACEME" },
+                                               { PTRACE_PEEKTEXT, "PTRACE_PEEKTEXT" },
+                                               { PTRACE_PEEKDATA, "PTRACE_PEEKDATA" },
+                                               { PTRACE_PEEKUSER, "PTRACE_PEEKUSER" },
+                                               { PTRACE_POKETEXT, "PTRACE_POKETEXT" },
+                                               { PTRACE_POKEDATA, "PTRACE_POKEDATA" },
+                                               { PTRACE_POKEUSER, "PTRACE_POKEUSER" },
+                                               { PTRACE_CONT, "PTRACE_CONT" },
+                                               { PTRACE_KILL, "PTRACE_KILL" },
+                                               { PTRACE_SINGLESTEP, "PTRACE_SINGLESTEP" },
+#    ifndef DR_HOST_AARCH64
+                                               { PTRACE_GETREGS, "PTRACE_GETREGS" },
+                                               { PTRACE_SETREGS, "PTRACE_SETREGS" },
+                                               { PTRACE_GETFPREGS, "PTRACE_GETFPREGS" },
+                                               { PTRACE_SETFPREGS, "PTRACE_SETFPREGS" },
+#    endif
+                                               { PTRACE_ATTACH, "PTRACE_ATTACH" },
+                                               { PTRACE_DETACH, "PTRACE_DETACH" },
+#    if defined(PTRACE_GETFPXREGS) && defined(PTRACE_SETFPXREGS)
+                                               { PTRACE_GETFPXREGS, "PTRACE_GETFPXREGS" },
+                                               { PTRACE_SETFPXREGS, "PTRACE_SETFPXREGS" },
+#    endif
+                                               { PTRACE_SYSCALL, "PTRACE_SYSCALL" },
+                                               { PTRACE_SETOPTIONS, "PTRACE_SETOPTIONS" },
+                                               { PTRACE_GETEVENTMSG,
+                                                 "PTRACE_GETEVENTMSG" },
+                                               { PTRACE_GETSIGINFO, "PTRACE_GETSIGINFO" },
+                                               { PTRACE_SETSIGINFO, "PTRACE_SETSIGINFO" },
+                                               { 0 } };
+
+/* Ptrace syscall wrapper, for logging.
+ * XXX: We could call libc's ptrace instead of using dynamorio_syscall.
+ * Initially I used the raw syscall to avoid adding a libc import, but calling
+ * libc from the injector process should always work.
+ */
+static long
+our_ptrace(int request, pid_t pid, void *addr, void *data)
+{
+    long r = dynamorio_syscall(SYS_ptrace, 4, request, pid, addr, data);
+    if (verbose &&
+        /* Don't log reads and writes. */
+        request != PTRACE_POKEDATA && request != PTRACE_PEEKDATA) {
+        const enum_name_pair_t *pair = NULL;
+        int i;
+        for (i = 0; pt_req_map[i].enum_name != NULL; i++) {
+            if (pt_req_map[i].enum_val == request) {
+                pair = &pt_req_map[i];
+                break;
+            }
+        }
+        ASSERT(pair != NULL);
+        fprintf(stderr, "\tptrace(%s, %d, %p, %p) -> %ld %s\n", pair->enum_name, (int)pid,
+                addr, data, r, strerror(-r));
+    }
+    return r;
+}
+#define ptrace DO_NOT_USE_ptrace_USE_our_ptrace
+
+
+/* Never actually called, but needed to link in config.c. */
+const char *
+get_application_short_name(void)
+{
+    ASSERT(false);
+    return "";
+}
+
+static void
+unexpected_trace_event(pid_t pid, int sig_expected, int sig_actual)
+{
+    if (verbose) {
+        app_pc err_pc;
+        our_ptrace(PTRACE_PEEKUSER, pid, (void *)REG_PC_OFFSET, &err_pc);
+        fprintf(stderr,
+                "Unexpected trace event.  Expected %s, got signal %d "
+                "at pc: %p\n",
+                strsignal(sig_expected), sig_actual, err_pc);
+    }
+}
+
+static bool
+wait_until_signal(pid_t pid, int sig)
+{
+    int status;
+    int r = waitpid(pid, &status, 0);
+    if (r < 0)
+        return false;
+    if (WIFSTOPPED(status) && WSTOPSIG(status) == sig) {
+        return true;
+    } else {
+        unexpected_trace_event(pid, sig, WSTOPSIG(status));
+        return false;
+    }
+}
+
+/* Continue until the next SIGTRAP.  Returns false and prints an error message
+ * if the next trap is not a breakpoint.
+ */
+static bool
+continue_until_break(pid_t pid)
+{
+    long r = our_ptrace(PTRACE_CONT, pid, NULL, NULL);
+    if (r < 0)
+        return false;
+    return wait_until_signal(pid, SIGTRAP);
+}
+
+static long
+our_ptrace_getregs(pid_t pid, struct USER_REGS_TYPE *regs)
+{
+#ifdef AARCH64
+    struct iovec iovec = { regs, sizeof(*regs) };
+    return our_ptrace(PTRACE_GETREGSET, pid, (void *)NT_PRSTATUS, &iovec);
+#else
+    return our_ptrace(PTRACE_GETREGS, pid, NULL, regs);
+#endif
+}
+
+static long
+our_ptrace_setregs(pid_t pid, struct USER_REGS_TYPE *regs)
+{
+#ifdef AARCH64
+    struct iovec iovec = { regs, sizeof(*regs) };
+    return our_ptrace(PTRACE_SETREGSET, pid, (void *)NT_PRSTATUS, &iovec);
+#else
+    return our_ptrace(PTRACE_SETREGS, pid, NULL, regs);
+#endif
+}
+
+/* Copies memory from traced process into parent.
+ */
+static bool
+ptrace_read_memory(pid_t pid, void *dst, void *src, size_t len)
+{
+    uint i;
+    ptr_int_t *dst_reg = dst;
+    ptr_int_t *src_reg = src;
+    ASSERT(len % sizeof(ptr_int_t) == 0); /* FIXME handle */
+    for (i = 0; i < len / sizeof(ptr_int_t); i++) {
+        /* We use a raw syscall instead of the libc wrapper, so the value read
+         * is stored in the data pointer instead of being returned in r.
+         */
+        long r = our_ptrace(PTRACE_PEEKDATA, pid, &src_reg[i], &dst_reg[i]);
+        if (r < 0)
+            return false;
+    }
+    return true;
+}
+
+/* Copies memory from parent into traced process.
+ */
+static bool
+ptrace_write_memory(pid_t pid, void *dst, void *src, size_t len)
+{
+    uint i;
+    ptr_int_t *dst_reg = dst;
+    ptr_int_t *src_reg = src;
+    ASSERT(len % sizeof(ptr_int_t) == 0); /* FIXME handle */
+    for (i = 0; i < len / sizeof(ptr_int_t); i++) {
+        long r = our_ptrace(PTRACE_POKEDATA, pid, &dst_reg[i], (void *)src_reg[i]);
+        if (r < 0)
+            return false;
+    }
+    return true;
+}
+
+/* Push a pointer to a string to the stack.  We create a fake instruction with
+ * raw bytes equal to the string we want to put in the injectee.  The call will
+ * pass these invalid instruction bytes, and the return address on the stack
+ * will point to the string.
+ */
+static void
+gen_push_string(void *dc, instrlist_t *ilist, const char *msg)
+{
+#ifdef X86
+    instr_t *after_msg = INSTR_CREATE_label(dc);
+    instr_t *msg_instr = instr_build_bits(dc, OP_UNDECODED, strlen(msg) + 1);
+    APP(ilist, INSTR_CREATE_call(dc, opnd_create_instr(after_msg)));
+    instr_set_raw_bytes(msg_instr, (byte *)msg, strlen(msg) + 1);
+    instr_set_raw_bits_valid(msg_instr, true);
+    APP(ilist, msg_instr);
+    APP(ilist, after_msg);
+#else
+    /* FIXME i#1551: NYI on ARM */
+    ASSERT_NOT_IMPLEMENTED(false);
+#endif /* X86 */
+}
+
+static void
+gen_syscall(void *dc, instrlist_t *ilist, int sysnum, uint num_opnds, opnd_t *args)
+{
+#ifdef X86
+    uint i;
+    ASSERT(num_opnds <= MAX_SYSCALL_ARGS);
+    APP(ilist,
+        INSTR_CREATE_mov_imm(dc, opnd_create_reg(DR_REG_XAX),
+                             OPND_CREATE_INTPTR(sysnum)));
+    for (i = 0; i < num_opnds; i++) {
+        if (opnd_is_immed_int(args[i]) || opnd_is_instr(args[i])) {
+            APP(ilist,
+                INSTR_CREATE_mov_imm(dc, opnd_create_reg(syscall_regparms[i]), args[i]));
+        } else if (opnd_is_base_disp(args[i])) {
+            APP(ilist,
+                INSTR_CREATE_mov_ld(dc, opnd_create_reg(syscall_regparms[i]), args[i]));
+        }
+    }
+    /* XXX: Reuse create_syscall_instr() in emit_utils.c. */
+#    ifdef X64
+    APP(ilist, INSTR_CREATE_syscall(dc));
+#    else
+    APP(ilist, INSTR_CREATE_int(dc, OPND_CREATE_INT8((char)0x80)));
+#    endif
+#else
+    /* FIXME i#1551: NYI on ARM */
+    ASSERT_NOT_IMPLEMENTED(false);
+#endif /* X86 */
+}
+
+/* singlestep traced process
+ */
+static bool
+ptrace_singlestep(pid_t pid)
+{
+    if (our_ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) < 0)
+        return false;
+
+    if (!wait_until_signal(pid, SIGTRAP))
+        return false;
+
+    return true;
+}
+
+/* Injects the code in ilist into the injectee and runs it, returning the value
+ * left in the return value register at the end of ilist execution.  Frees
+ * ilist.  Returns -EUNATCH if anything fails before executing the syscall.
+ */
+static ptr_int_t
+injectee_run_get_retval(pid_t pid, void *dc, instrlist_t *ilist)
+{
+    struct USER_REGS_TYPE regs;
+    byte shellcode[MAX_SHELL_CODE];
+    byte orig_code[MAX_SHELL_CODE];
+    app_pc end_pc;
+    size_t code_size;
+    ptr_int_t ret;
+    app_pc pc;
+    long r;
+    ptr_int_t failure = -EUNATCH; /* Unlikely to be used by most syscalls. */
+
+    /* Get register state before executing the shellcode. */
+    r = our_ptrace_getregs(pid, &regs);
+    if (r < 0)
+        return r;
+
+    /* Use the current PC's page, since it's executable.  Our shell code is
+     * always less than one page, so we won't overflow.
+     */
+    pc = (app_pc)ALIGN_BACKWARD(regs.REG_PC_FIELD, PAGE_SIZE);
+
+    /* Append an int3 so we can catch the break. */
+    APP(ilist, XINST_CREATE_debug_instr(dc));
+    if (verbose) {
+        fprintf(stderr, "injecting code:\n");
+#if defined(INTERNAL) || defined(DEBUG) || defined(CLIENT_INTERFACE)
+        /* XXX: This disas call aborts on our raw bytes instructions.  Can we
+         * teach DR's disassembler to avoid those instrs?
+         */
+        instrlist_disassemble(dc, pc, ilist, STDERR);
+#endif
+    }
+
+    /* Encode ilist into shellcode. */
+    end_pc = instrlist_encode_to_copy(dc, ilist, shellcode, pc,
+                                      &shellcode[MAX_SHELL_CODE], true /*jmp*/);
+    code_size = end_pc - &shellcode[0];
+    code_size = ALIGN_FORWARD(code_size, sizeof(reg_t));
+    ASSERT(code_size <= MAX_SHELL_CODE);
+    instrlist_clear_and_destroy(dc, ilist);
+
+    /* Copy shell code into injectee at the current PC. */
+    if (!ptrace_read_memory(pid, orig_code, pc, code_size) ||
+        !ptrace_write_memory(pid, pc, shellcode, code_size))
+        return failure;
+
+    /* Run it! */
+    our_ptrace(PTRACE_POKEUSER, pid, (void *)REG_PC_OFFSET, pc);
+    if (!continue_until_break(pid))
+        return failure;
+
+    /* Get return value. */
+    ret = failure;
+    r = our_ptrace(PTRACE_PEEKUSER, pid,
+               (void *)offsetof(struct USER_REGS_TYPE, REG_RETVAL_FIELD), &ret);
+    if (r < 0)
+        return r;
+
+    /* Put back original code and registers. */
+    if (!ptrace_write_memory(pid, pc, orig_code, code_size))
+        return failure;
+    r = our_ptrace_setregs(pid, &regs);
+    if (r < 0)
+        return r;
+
+    return ret;
+}
+
+static int
+injectee_detach_dr(pid_t pid)
+{
+    struct USER_REGS_TYPE regs, regs_old;
+    long r;
+
+    app_pc callee_ip = read_dr_app_stop_and_clean_pc(pid);
+    ptr_int_t failure = -EUNATCH;
+
+    /* Get register state before executing the shellcode. */
+    r = our_ptrace_getregs(pid, &regs_old);
+    if (r < 0)
+        return r;
+    regs = regs_old;
+    regs.REG_PC_FIELD = (uint64_t)callee_ip;
+    if (verbose) {
+        fprintf(stderr, "injectee old pc %p\n", (void*)regs_old.REG_PC_FIELD);
+        fprintf(stderr, "injectee new pc %p\n", (void*)regs.REG_PC_FIELD);
+    }
+    r = our_ptrace_setregs(pid, &regs);
+    if (r < 0)
+        return r;
+
+    int status;
+    int signal;    
+    signal = 0;
+    do {
+        /* Continue or deliver pending signal from status. */
+        r = our_ptrace(PTRACE_CONT, pid, NULL, (void *)(ptr_int_t)signal);
+        if (r < 0)
+            return r;
+        r = waitpid(pid, &status, 0);
+        if (r < 0 || !WIFSTOPPED(status))
+            return r;
+        signal = WSTOPSIG(status);
+    } while (signal == SIGSEGV || signal == SIGILL);
+    if (signal != SIGTRAP) {
+        unexpected_trace_event(pid, SIGTRAP, signal);
+        return failure;
+    }
+    r = our_ptrace_setregs(pid, &regs_old);
+    if (r < 0)
+        return r;
+    if (verbose) {
+        fprintf(stderr, "injectee_detach_dr success\n");
+    }
+    return 1;
+}
+
+static int
+injectee_open(pid_t pid, const char *path, int flags, mode_t mode)
+{
+    void *dc = GLOBAL_DCONTEXT;
+    instrlist_t *ilist = instrlist_create(dc);
+    opnd_t args[MAX_SYSCALL_ARGS];
+    int num_args = 0;
+    gen_push_string(dc, ilist, path);
+#ifndef SYS_open
+    args[num_args++] = OPND_CREATE_INTPTR(AT_FDCWD);
+#endif
+    args[num_args++] = OPND_CREATE_MEMPTR(REG_XSP, 0);
+    args[num_args++] = OPND_CREATE_INTPTR(flags);
+    args[num_args++] = OPND_CREATE_INTPTR(mode);
+    ASSERT(num_args <= MAX_SYSCALL_ARGS);
+#ifdef SYS_open
+    gen_syscall(dc, ilist, SYSNUM_NO_CANCEL(SYS_open), num_args, args);
+#else
+    gen_syscall(dc, ilist, SYSNUM_NO_CANCEL(SYS_openat), num_args, args);
+#endif
+    return injectee_run_get_retval(pid, dc, ilist);
+}
+
+static void *
+injectee_mmap(pid_t pid, void *addr, size_t sz, int prot, int flags, int fd, off_t offset)
+{
+    void *dc = GLOBAL_DCONTEXT;
+    instrlist_t *ilist = instrlist_create(dc);
+    opnd_t args[MAX_SYSCALL_ARGS];
+    int num_args = 0;
+    args[num_args++] = OPND_CREATE_INTPTR(addr);
+    args[num_args++] = OPND_CREATE_INTPTR(sz);
+    args[num_args++] = OPND_CREATE_INTPTR(prot);
+    args[num_args++] = OPND_CREATE_INTPTR(flags);
+    args[num_args++] = OPND_CREATE_INTPTR(fd);
+    args[num_args++] = OPND_CREATE_INTPTR(IF_X64_ELSE(offset, offset >> 12));
+    ASSERT(num_args <= MAX_SYSCALL_ARGS);
+    /* XXX: Regular mmap gives EBADR on ia32, but mmap2 works. */
+    gen_syscall(dc, ilist, IF_X64_ELSE(SYS_mmap, SYS_mmap2), num_args, args);
+    return (void *)injectee_run_get_retval(pid, dc, ilist);
+}
+
+/* Do an mmap syscall in the injectee, parallel to the os_map_file prototype.
+ * Passed to elf_loader_map_phdrs to map DR into the injectee.  Uses the globals
+ * injector_dr_fd to injectee_dr_fd to map the former to the latter.
+ */
+static byte *
+injectee_map_file(file_t f, size_t *size INOUT, uint64 offs, app_pc addr, uint prot,
+                  map_flags_t map_flags)
+{
+    int fd;
+    int flags = 0;
+    app_pc r;
+    if (TEST(MAP_FILE_COPY_ON_WRITE, map_flags))
+        flags |= MAP_PRIVATE;
+    if (TEST(MAP_FILE_FIXED, map_flags))
+        flags |= MAP_FIXED;
+    /* MAP_FILE_IMAGE is a nop on Linux. */
+    if (f == injector_dr_fd)
+        fd = injectee_dr_fd;
+    else
+        fd = f;
+    if (fd == -1) {
+        flags |= MAP_ANONYMOUS;
+    }
+    r = injectee_mmap(injectee_pid, addr, *size, memprot_to_osprot(prot), flags, fd,
+                      offs);
+    if (!mmap_syscall_succeeded(r)) {
+        int err = -(int)(ptr_int_t)r;
+        printf("injectee_mmap(%d, %p, %p, 0x%x, 0x%lx, 0x%x) -> (%d): %s\n", fd, addr,
+               (void *)*size, memprot_to_osprot(prot), (long)offs, flags, err,
+               strerror(err));
+        return NULL;
+    }
+    return r;
+}
+
+/* Do an munmap syscall in the injectee. */
+static bool
+injectee_unmap(byte *addr, size_t size)
+{
+    void *dc = GLOBAL_DCONTEXT;
+    instrlist_t *ilist = instrlist_create(dc);
+    opnd_t args[MAX_SYSCALL_ARGS];
+    ptr_int_t r;
+    int num_args = 0;
+    args[num_args++] = OPND_CREATE_INTPTR(addr);
+    args[num_args++] = OPND_CREATE_INTPTR(size);
+    ASSERT(num_args <= MAX_SYSCALL_ARGS);
+    gen_syscall(dc, ilist, SYS_munmap, num_args, args);
+    r = injectee_run_get_retval(injectee_pid, dc, ilist);
+    if (r < 0) {
+        printf("injectee_munmap(%p, %p) -> %p\n", addr, (void *)size, (void *)r);
+        return false;
+    }
+    return true;
+}
+
+/* Do an mprotect syscall in the injectee. */
+static bool
+injectee_prot(byte *addr, size_t size, uint prot /*MEMPROT_*/)
+{
+    void *dc = GLOBAL_DCONTEXT;
+    instrlist_t *ilist = instrlist_create(dc);
+    opnd_t args[MAX_SYSCALL_ARGS];
+    ptr_int_t r;
+    int num_args = 0;
+    args[num_args++] = OPND_CREATE_INTPTR(addr);
+    args[num_args++] = OPND_CREATE_INTPTR(size);
+    args[num_args++] = OPND_CREATE_INTPTR(memprot_to_osprot(prot));
+    ASSERT(num_args <= MAX_SYSCALL_ARGS);
+    gen_syscall(dc, ilist, SYS_mprotect, num_args, args);
+    r = injectee_run_get_retval(injectee_pid, dc, ilist);
+    if (r < 0) {
+        printf("injectee_prot(%p, %p, %x) -> %d\n", addr, (void *)size, prot, (int)r);
+        return false;
+    }
+    return true;
+}
+
+/* Convert a user_regs_struct used by the ptrace API into DR's priv_mcontext_t
+ * struct.
+ */
+static void
+user_regs_to_mc(priv_mcontext_t *mc, struct USER_REGS_TYPE *regs)
+{
+#ifdef X86
+#    ifdef X64
+    mc->rip = (app_pc)regs->rip;
+    mc->rax = regs->rax;
+    mc->rcx = regs->rcx;
+    mc->rdx = regs->rdx;
+    mc->rbx = regs->rbx;
+    mc->rsp = regs->rsp;
+    mc->rbp = regs->rbp;
+    mc->rsi = regs->rsi;
+    mc->rdi = regs->rdi;
+    mc->r8 = regs->r8;
+    mc->r9 = regs->r9;
+    mc->r10 = regs->r10;
+    mc->r11 = regs->r11;
+    mc->r12 = regs->r12;
+    mc->r13 = regs->r13;
+    mc->r14 = regs->r14;
+    mc->r15 = regs->r15;
+#    else
+    mc->eip = (app_pc)regs->eip;
+    mc->eax = regs->eax;
+    mc->ecx = regs->ecx;
+    mc->edx = regs->edx;
+    mc->ebx = regs->ebx;
+    mc->esp = regs->esp;
+    mc->ebp = regs->ebp;
+    mc->esi = regs->esi;
+    mc->edi = regs->edi;
+#    endif
+#elif defined(ARM)
+    mc->r0 = regs->uregs[0];
+    mc->r1 = regs->uregs[1];
+    mc->r2 = regs->uregs[2];
+    mc->r3 = regs->uregs[3];
+    mc->r4 = regs->uregs[4];
+    mc->r5 = regs->uregs[5];
+    mc->r6 = regs->uregs[6];
+    mc->r7 = regs->uregs[7];
+    mc->r8 = regs->uregs[8];
+    mc->r9 = regs->uregs[9];
+    mc->r10 = regs->uregs[10];
+    mc->r11 = regs->uregs[11];
+    mc->r12 = regs->uregs[12];
+    mc->r13 = regs->uregs[13];
+    mc->r14 = regs->uregs[14];
+    mc->r15 = regs->uregs[15];
+    mc->cpsr = regs->uregs[16];
+#elif defined(AARCH64)
+    ASSERT_NOT_IMPLEMENTED(false); /* FIXME i#1569 */
+#endif /* X86/ARM */
+}
+
+static file_t
+init_attach_callpath_pc_config(pid_t pid) {
+    char attach_callpath_config_name[MAXIMUM_PATH] = "";
+    sprintf(attach_callpath_config_name + strlen(attach_callpath_config_name), "/home/dolanwm/.dynamorio/drcctprof.callpath.pc.attach.%d", pid);
+    if(os_file_exists(attach_callpath_config_name, false)) {
+        os_delete_file(attach_callpath_config_name);
+    }
+    if(verbose) {
+        fprintf(stderr, "init callpath.config \"%s\"\n", attach_callpath_config_name);
+    }
+    return  os_open(attach_callpath_config_name, OS_OPEN_READ | OS_OPEN_WRITE);
+}
+
+static file_t
+init_attach_callpath_sym_config(pid_t pid) {
+    char attach_callpath_config_name[MAXIMUM_PATH] = "";
+    sprintf(attach_callpath_config_name + strlen(attach_callpath_config_name), "/home/dolanwm/.dynamorio/drcctprof.callpath.sym.attach.%d", pid);
+    if(os_file_exists(attach_callpath_config_name, false)) {
+        os_delete_file(attach_callpath_config_name);
+    }
+    if(verbose) {
+        fprintf(stderr, "init callpath.config \"%s\"\n", attach_callpath_config_name);
+    }
+    return  os_open(attach_callpath_config_name, OS_OPEN_READ | OS_OPEN_WRITE);
+}
+
+static void
+get_call_path(pid_t pid)
+{
+    unw_cursor_t resume_cursor;
+
+    unw_addr_space_t addr_space = unw_create_addr_space(&_UPT_accessors, __BYTE_ORDER__);
+    if (!addr_space)
+        fprintf(stderr, "Failed to create address space\n");
+
+    void *rctx = _UPT_create(pid);
+
+    if (rctx == NULL)
+        fprintf(stderr, "Failed to _UPT_create\n");
+
+    if (unw_init_remote(&resume_cursor, addr_space, rctx))
+        fprintf(stderr, "unw_init_remote failed\n");
+    file_t attach_callpath_pc_config = init_attach_callpath_pc_config(pid);
+    file_t attach_callpath_sym_config = init_attach_callpath_sym_config(pid);
+    // Unwind frames one by one, going up the frame stack.
+    while (unw_step(&resume_cursor) > 0) {
+        unw_word_t offset, pc;
+        unw_get_reg(&resume_cursor, UNW_REG_IP, &pc);
+        if (pc == 0) {
+            break;
+        }
+        fprintf(stderr, "0x%lx:", pc);
+        char buff[17];
+        memset(buff, '\0', 17);
+        sprintf(buff, "%lx", pc);
+        char pc_char[17];
+        memset(pc_char, '0', 17);
+        for(int i = strlen(buff), j = 15; i>=0; i--, j--) {
+            pc_char[j] = buff[i];
+        }
+        pc_char[16] = '\0';
+        os_write(attach_callpath_pc_config, pc_char, 16);
+
+        char sym_buff[256];
+        memset(sym_buff, '\0', 256);
+        char sym[256];
+        if (unw_get_proc_name(&resume_cursor, sym, sizeof(sym), &offset) == 0) {
+            sprintf(sym_buff, "%s(%d)", sym, 0);
+            fprintf(stderr, " (%s+0x%lx)\n", sym, offset);
+        } else {
+            sprintf(sym_buff, "badip(0)");
+            fprintf(stderr, " -- error: unable to obtain symbol name for this frame\n");
+        }
+        os_write(attach_callpath_sym_config, sym_buff, 256);
+    }
+    os_close(attach_callpath_pc_config);
+    os_close(attach_callpath_sym_config);
+    // _UPT_resume(addr_space, &resume_cursor, rctx);
+    _UPT_destroy(rctx);
+}
+
+typedef enum {
+    INJECT_SUCCESS,
+    INJECT_ERROR_NEED_DETACH,
+    INJECT_ERROR_NOT_NEED_DETACH
+} inject_status_t;
+
+static inject_status_t
+inject_attach_ptrace(pid_t pid, const char *library_path)
+{
+    long r;
+    int dr_fd;
+    struct USER_REGS_TYPE regs;
+    ptrace_stack_args_t args;
+    app_pc injected_base;
+    app_pc injected_dr_start;
+    elf_loader_t loader;
+    int status;
+    int signal;
+
+    delete_last_attach_config(pid);
+
+    /* Attach to the process in question. */
+    r = our_ptrace(PTRACE_ATTACH, pid, NULL, NULL);
+    if (r < 0) {
+        if (verbose) {
+            fprintf(stderr, "PTRACE_ATTACH failed with error: %s\n", strerror(-r));
+        }
+        return INJECT_ERROR_NOT_NEED_DETACH;
+    }
+    if (!wait_until_signal(pid, SIGSTOP))
+        return INJECT_ERROR_NEED_DETACH;
+    if (!ptrace_singlestep(pid))
+        return INJECT_ERROR_NEED_DETACH;
+    
+    get_call_path(pid);
+    // return INJECT_ERROR_NEED_DETACH;
+
+    /* Open libdynamorio.so as readonly in the child. */
+    dr_fd = injectee_open(pid, library_path, O_RDONLY, 0);
+    if (dr_fd < 0) {
+        if (verbose) {
+            fprintf(stderr,
+                    "Unable to open %s in injectee (%d): "
+                    "%s\n",
+                    library_path,
+                    -dr_fd, strerror(-dr_fd));
+        }
+        return INJECT_ERROR_NEED_DETACH;
+    }
+
+    /* Call our private loader, but perform the mmaps in the child process
+     * instead of the parent.
+     */
+    if (!elf_loader_read_headers(&loader, library_path))
+        return INJECT_ERROR_NEED_DETACH;
+    /* XXX: Have to use globals to communicate to injectee_map_file. =/ */
+    injector_dr_fd = loader.fd;
+    injectee_dr_fd = dr_fd;
+    injectee_pid = pid;
+    injected_base = elf_loader_map_phdrs(&loader, true /*fixed*/, injectee_map_file,
+                                         injectee_unmap, injectee_prot, NULL,
+                                         MODLOAD_SEPARATE_PROCESS /*!reachable*/);
+    if (injected_base == NULL) {
+        if (verbose)
+            fprintf(stderr, "Unable to mmap libdynamorio.so in injectee\n");
+        return INJECT_ERROR_NEED_DETACH;
+    }
+    /* Looking up exports through ptrace is hard, so we use the e_entry from
+     * the ELF header with different arguments.
+     * XXX: Actually look up an export.
+     */
+    injected_dr_start = (app_pc)loader.ehdr->e_entry + loader.load_delta;
+    elf_loader_destroy(&loader);
+
+    our_ptrace_getregs(pid, &regs);
+
+    /* Create an injection context and "push" it onto the stack of the injectee.
+     * If you need to pass more info to the injected child process, this is a
+     * good place to put it.
+     */
+    memset(&args, 0, sizeof(args));
+    user_regs_to_mc(&args.mc, &regs);
+    args.argc = ARGC_PTRACE_SENTINEL;
+
+    /* We need to send the home directory over.  It's hard to find the
+     * environment in the injectee, and even if we could HOME might be
+     * different.
+     */
+    strncpy(args.home_dir, getenv("HOME"), BUFFER_SIZE_ELEMENTS(args.home_dir));
+    NULL_TERMINATE_BUFFER(args.home_dir);
+
+    regs.REG_SP_FIELD -= REDZONE_SIZE; /* Need to preserve x64 red zone. */
+    regs.REG_SP_FIELD -= sizeof(args); /* Allocate space for args. */
+    regs.REG_SP_FIELD = ALIGN_BACKWARD(regs.REG_SP_FIELD, REGPARM_END_ALIGN);
+    ptrace_write_memory(pid, (void *)regs.REG_SP_FIELD, &args, sizeof(args));
+
+    regs.REG_PC_FIELD = (ptr_int_t)injected_dr_start;
+    our_ptrace_setregs(pid, &regs);
+
+    /* This should run something equivalent to dynamorio_app_init(), and then
+     * return.
+     * XXX: we can actually fault during dynamorio_app_init() due to safe_reads,
+     * so we have to expect SIGSEGV and let it be delivered.
+     * XXX: SIGILL is delivered from signal_arch_init() and we should pass it
+     * to its original handler.
+     */
+    signal = 0;
+    do {
+        /* Continue or deliver pending signal from status. */
+        r = our_ptrace(PTRACE_CONT, pid, NULL, (void *)(ptr_int_t)signal);
+        if (r < 0)
+            return INJECT_ERROR_NEED_DETACH;
+        r = waitpid(pid, &status, 0);
+        if (r < 0 || !WIFSTOPPED(status))
+            return INJECT_ERROR_NEED_DETACH;
+        signal = WSTOPSIG(status);
+    } while (signal == SIGSEGV || signal == SIGILL);
+
+    /* When we get SIGTRAP, DR has initialized. */
+    if (signal != SIGTRAP) {
+        unexpected_trace_event(pid, SIGTRAP, signal);
+        return INJECT_ERROR_NEED_DETACH;
+    }
+    return INJECT_SUCCESS;
+}
+
+static inject_status_t
+inject_detach_ptrace(pid_t pid)
+{
+    long r;
+
+    /* Attach to the process in question. */
+    r = our_ptrace(PTRACE_ATTACH, pid, NULL, NULL);
+    if (r < 0) {
+        if (verbose) {
+            fprintf(stderr, "PTRACE_ATTACH failed with error: %s\n", strerror(-r));
+        }
+        return INJECT_ERROR_NOT_NEED_DETACH;
+    }
+    if (!wait_until_signal(pid, SIGSTOP))
+        return INJECT_ERROR_NEED_DETACH;
+    if (!ptrace_singlestep(pid))
+        return INJECT_ERROR_NEED_DETACH;
+    
+    r = injectee_detach_dr(pid);
+    if (r < 0) {
+        if (verbose) {
+            fprintf(stderr, "injectee_detach_dr failed with error: %s\n", strerror(-r));
+        }
+        return INJECT_ERROR_NEED_DETACH;
+    }
+    return INJECT_SUCCESS;
+}
+
+
+DR_EXPORT
+bool
+drcct_attach_inject_ptrace(pid_t pid, const char *appname, bool verbose_on)
+{
+    verbose = verbose_on;
+    char library_path[MAXIMUM_PATH];
+    if (!get_config_val_other_app(appname, pid,
+                                  IF_X64_ELSE(DR_PLATFORM_64BIT, DR_PLATFORM_32BIT),
+                                  DYNAMORIO_VAR_AUTOINJECT, library_path,
+                                  BUFFER_SIZE_ELEMENTS(library_path), NULL, NULL, NULL)) {
+        if (verbose) {
+            fprintf(stderr, "get inject library path failed\n");
+        }
+        return false;
+    }
+
+    inject_status_t status = inject_attach_ptrace(pid, library_path);
+    if (status != INJECT_ERROR_NOT_NEED_DETACH) {
+        our_ptrace(PTRACE_DETACH, pid, NULL, NULL);
+    }
+    if (status != INJECT_SUCCESS) {
+        return false;
+    }
+    return true;
+}
+
+DR_EXPORT
+bool
+drcct_detach_inject_ptrace(pid_t pid, bool verbose_on)
+{
+    verbose = verbose_on;
+
+    inject_status_t status = inject_detach_ptrace(pid);
+    if (status != INJECT_ERROR_NOT_NEED_DETACH) {
+        our_ptrace(PTRACE_DETACH, pid, NULL, NULL);
+    }
+    if (status != INJECT_SUCCESS) {
+        return false;
+    }
+    return true;
+}
diff --git a/core/unix/loader.c b/core/unix/loader.c
index a803590f..73b02289 100644
--- a/core/unix/loader.c
+++ b/core/unix/loader.c
@@ -1500,6 +1500,7 @@ takeover_ptrace(ptrace_stack_args_t *args)
     NULL_TERMINATE_BUFFER(home_var);
     dynamorio_set_envp(fake_envp);
 
+    dynamorio_app_pre_init();
     dynamorio_app_init();
 
     /* FIXME i#37: takeover other threads */
diff --git a/core/unix/signal.c b/core/unix/signal.c
index 11be4a0a..939d82d5 100644
--- a/core/unix/signal.c
+++ b/core/unix/signal.c
@@ -7193,6 +7193,9 @@ signal_to_itimer_type(int sig)
 static bool
 alarm_signal_has_DR_only_itimer(dcontext_t *dcontext, int signal)
 {
+    if (dcontext == GLOBAL_DCONTEXT) {
+        return false;
+    }
     thread_sig_info_t *info = (thread_sig_info_t *)dcontext->signal_field;
     int which = signal_to_itimer_type(signal);
     if (which == -1)
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 51186dcb..df68e765 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -178,6 +178,10 @@ add_executable(drinject drdeploy.c ${RESOURCES})
 set_target_properties(drinject PROPERTIES
   COMPILE_FLAGS "${tool_cflags}" COMPILE_DEFINITIONS "RC_IS_drinject;DRINJECT")
 set(tgts ${tgts} drconfig drrun drinject)
+if (UNIX)
+  add_executable(drcctprof drcctprof.c)
+  target_link_libraries(drcctprof drconfiglib drfrontendlib drcctattachlib)
+endif (UNIX)
 
 foreach (deploytgt drconfig drrun drinject)
   copy_target_to_device(${deploytgt} "${location_suffix}")
diff --git a/tools/drcctprof.c b/tools/drcctprof.c
new file mode 100644
index 00000000..41a94287
--- /dev/null
+++ b/tools/drcctprof.c
@@ -0,0 +1,622 @@
+/* 
+ *  Copyright (c) 2020-2021 Xuhpclab. All rights reserved.
+ *  Licensed under the MIT License.
+ *  See LICENSE file for more information.
+ */
+
+#include "configure.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <sys/wait.h>
+
+#include <string.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+#include <assert.h>
+#include <ctype.h>
+
+#include "globals_shared.h"
+#include "dr_config.h"
+#include "dr_frontend.h"
+#include "drcct_attach.h"
+
+static bool verbose;
+static bool quiet;
+
+#define die() exit(1)
+
+#define fatal(msg, ...)                                     \
+    do {                                                    \
+        fprintf(stderr, "ERROR: " msg "\n", ##__VA_ARGS__); \
+        fflush(stderr);                                     \
+        exit(1);                                            \
+    } while (0)
+
+/* up to caller to call die() if necessary */
+#define error(msg, ...)                                     \
+    do {                                                    \
+        fprintf(stderr, "ERROR: " msg "\n", ##__VA_ARGS__); \
+        fflush(stderr);                                     \
+    } while (0)
+
+#define warn(msg, ...)                                            \
+    do {                                                          \
+        if (!quiet) {                                             \
+            fprintf(stderr, "WARNING: " msg "\n", ##__VA_ARGS__); \
+            fflush(stderr);                                       \
+        }                                                         \
+    } while (0)
+
+#define info(msg, ...)                                         \
+    do {                                                       \
+        if (verbose) {                                         \
+            fprintf(stderr, "INFO: " msg "\n", ##__VA_ARGS__); \
+            fflush(stderr);                                    \
+        }                                                      \
+    } while (0)
+
+#define TOOLNAME "drcctprof"
+
+const char *usage_str =
+    "USAGE: " TOOLNAME " -attach <pid> [-ops options] -t <toolname> <options>*\n"
+    "   or: " TOOLNAME " -attach <pid> [-ops options] -c <path> <options>*\n"
+    "   or: " TOOLNAME " -detach <pid>\n";
+
+const char *options_list_str =
+    "\n" TOOLNAME " options (these are distinct from DR runtime options):\n"
+    "       -version           Display version information\n"
+    "       -verbose           Display additional information\n"
+    "       -quiet             Do not display warnings\n"
+    "       -debug             Use the DR debug library\n"
+    "\n"
+    "       -ops \"<options>\"\n"
+    "                          Specify DR runtime options.  When specifying\n"
+    "                          multiple options, enclose the entire list of\n"
+    "                          options in quotes, or repeat the -ops.\n"
+    "                          Alternatively, if -c or -t is specified, the -ops\n"
+    "                          may be omitted and DR options listed prior to -c,\n"
+    "                          and -t, without quotes.\n"
+    "       -attach <pid>\n"
+    "                          Attach to the process with the given pid.\n"
+    "       -process <pid> \n"
+    "       -detach <pid>\n"
+    "                          Detach dr from process with the given pid.\n"
+    "       -logdir <dir>\n"
+    "                          Logfiles will be stored in this directory.\n"
+    "\n"
+    "        -t <toolname> <options>\n"
+    "                           Registers a pre-configured tool to run alongside DR.\n"
+    "                           A tool is a client with a configuration file\n"
+    "                           that sets the client options and path, providing a\n"
+    "                           convenient launching command via this -t parameter.\n"
+    "                           Available tools include: %s.\n"
+    "                           All remaining arguments are interpreted as client\n"
+    "                           options. Must come after all drrun and DR ops.\n"
+    "                           Neither the path nor the options may contain semicolon\n"
+    "                           characters or all 3 quote characters (\", \', `).\n"
+    "\n"
+    "        -c <path> <options>\n"
+    "                           Registers one client to run alongside DR.  Assigns\n"
+    "                           the client an id of 0.  All remaining arguments\n"
+    "                           are interpreted as client options. Must come after \n"
+    "                           all drrun and DR ops. Neither the path nor\n"
+    "                           the options may contain semicolon characters or\n"
+    "                           all 3 quote characters (\", \', `).\n";
+
+static bool
+does_file_exist(const char *path)
+{
+    bool ret = false;
+    return (drfront_access(path, DRFRONT_EXIST, &ret) == DRFRONT_SUCCESS && ret);
+}
+
+static void
+get_absolute_path(const char *src, char *buf, size_t buflen /*# elements*/)
+{
+    drfront_status_t sc = drfront_get_absolute_path(src, buf, buflen);
+    if (sc != DRFRONT_SUCCESS)
+        fatal("failed (status=%d) to convert %s to an absolute path", sc, src);
+}
+
+/* Opens a filename and mode that are in utf8 */
+static FILE *
+fopen_utf8(const char *path, const char *mode)
+{
+    return fopen(path, mode);
+}
+
+static char tool_list[MAXIMUM_PATH];
+
+static void
+print_tool_list(FILE *stream)
+{
+    if (tool_list[0] != '\0')
+        fprintf(stream, "       available tools include: %s\n", tool_list);
+}
+
+static void
+read_tool_list(const char *dr_root)
+{
+    FILE *f;
+    char list_file[MAXIMUM_PATH];
+    size_t sofar = 0;
+    const char *arch = IF_X64_ELSE("64", "32");
+    _snprintf(list_file, BUFFER_SIZE_ELEMENTS(list_file), "%s/tools/list%s", dr_root,
+              arch);
+    NULL_TERMINATE_BUFFER(list_file);
+    f = fopen_utf8(list_file, "r");
+    if (f == NULL) {
+        /* no visible error: we only expect to have a list for a package build */
+        return;
+    }
+    while (fgets(tool_list + sofar,
+                 (int)(BUFFER_SIZE_ELEMENTS(tool_list) - sofar - 1 /*space*/),
+                 f) != NULL) {
+        NULL_TERMINATE_BUFFER(tool_list);
+        sofar += strlen(tool_list + sofar);
+        tool_list[sofar - 1] = ','; /* replace newline with comma */
+        /* add space */
+        if (sofar < BUFFER_SIZE_ELEMENTS(tool_list))
+            tool_list[sofar++] = ' ';
+    }
+    fclose(f);
+    tool_list[sofar - 2] = '\0';
+    NULL_TERMINATE_BUFFER(tool_list);
+}
+
+#define usage(list_ops, msg, ...)                                                \
+    do {                                                                         \
+        FILE *stream = (list_ops == true) ? stdout : stderr;                     \
+        if ((msg)[0] != '\0')                                                    \
+            fprintf(stderr, "ERROR: " msg "\n\n", ##__VA_ARGS__);                \
+        fprintf(stream, "%s", usage_str);                                        \
+        print_tool_list(stream);                                                 \
+        if (list_ops) {                                                          \
+            fprintf(stream, options_list_str, tool_list);                        \
+            exit(0);                                                             \
+        } else {                                                                 \
+            fprintf(stream, "Run with -help to see " TOOLNAME " option list\n"); \
+        }                                                                        \
+        die();                                                                   \
+    } while (0)
+
+/* Unregister a process */
+bool
+unregister_proc(const char *process, pid_t pid)
+{
+    dr_config_status_t status = dr_unregister_process(process, pid, false, DR_PLATFORM_DEFAULT);
+    if (status == DR_PROC_REG_INVALID) {
+        error("no existing registration for %s", process == NULL ? "<null>" : process);
+        return false;
+    } else if (status == DR_FAILURE) {
+        error("unregistration failed for %s", process == NULL ? "<null>" : process);
+        return false;
+    }
+    return true;
+}
+
+/* Check if the provided root directory actually has the files we
+ * expect.  Returns whether a fatal problem.
+ */
+static bool
+check_dr_root(const char *dr_root, bool debug)
+{
+    char buf[MAXIMUM_PATH];
+    const char *arch = IF_X64_ELSE("lib64", "lib32");
+    const char *version = debug ? "debug" : "release";
+
+    _snprintf(buf, BUFFER_SIZE_ELEMENTS(buf), "%s/%s/%s/libdynamorio.so", dr_root, arch, version);
+    if (!does_file_exist(buf)) {
+        error("cannot find required file %s\n", buf);
+        return false;
+    }
+    return true;
+}
+
+/* Register a process to run under DR */
+bool
+register_proc(const char *process, pid_t pid, const char *dr_root, bool debug,
+              const char *extra_ops)
+{
+    dr_config_status_t status;
+    assert(dr_root != NULL);
+    if (!does_file_exist(dr_root)) {
+        error("cannot access DynamoRIO root directory %s", dr_root);
+        return false;
+    }
+
+    if (!check_dr_root(dr_root, debug))
+        return false;
+
+    if (dr_process_is_registered(process, pid, false, DR_PLATFORM_DEFAULT, NULL, NULL, NULL,
+                                 NULL)) {
+        warn("overriding existing registration");
+        if (!unregister_proc(process, pid))
+            return false;
+    }
+
+    status = dr_register_process(process, pid, false, dr_root, DR_MODE_CODE_MANIPULATION, debug,
+                                 DR_PLATFORM_DEFAULT, extra_ops);
+
+    if (status != DR_SUCCESS) {
+        /* USERPROFILE is not set by default over cygwin ssh */
+        char buf[MAXIMUM_PATH];
+            if (status == DR_CONFIG_DIR_NOT_FOUND) {
+                dr_get_config_dir(false, true /*tmp*/, buf, BUFFER_SIZE_ELEMENTS(buf));
+                error("process %s registration failed: check config dir %s permissions",
+                      process == NULL ? "<null>" : process, buf);
+            } else {
+                error("process %s registration failed",
+                      process == NULL ? "<null>" : process);
+            }
+        return false;
+    }
+    return true;
+}
+
+/* Check if the specified client library actually exists. */
+void
+check_client_lib(const char *client_lib)
+{
+    if (!does_file_exist(client_lib)) {
+        warn("%s does not exist", client_lib);
+    }
+}
+
+bool
+register_client(const char *process_name, pid_t pid, client_id_t client_id,
+                const char *path, const char *options)
+{
+    size_t priority;
+    dr_config_status_t status;
+    if (!dr_process_is_registered(process_name, pid, false, DR_PLATFORM_DEFAULT, NULL, NULL,
+                                  NULL, NULL)) {
+        error("can't register client: process %s is not registered",
+              process_name == NULL ? "<null>" : process_name);
+        return false;
+    }
+
+    check_client_lib(path);
+
+    /* just append to the existing client list */
+    priority = dr_num_registered_clients(process_name, pid, false, DR_PLATFORM_DEFAULT);
+
+    info("registering client with id=%d path=|%s| ops=|%s|", client_id, path, options);
+    dr_config_client_t info;
+    info.struct_size = sizeof(info);
+    info.id = client_id;
+    info.priority = priority;
+    info.path = (char *)path;
+    info.options = (char *)options;
+    info.is_alt_bitwidth = false;
+    status = dr_register_client_ex(process_name, pid, false, DR_PLATFORM_DEFAULT, &info);
+    if (status != DR_SUCCESS) {
+        if (status == DR_CONFIG_STRING_TOO_LONG) {
+            error("client %s registration failed: option string too long: \"%s\"", path,
+                  options);
+        } else if (status == DR_CONFIG_OPTIONS_INVALID) {
+            error("client %s registration failed: options cannot contain ';' or all "
+                  "3 quote types: %s",
+                  path, options);
+        } else {
+            error("client %s registration failed with error code %d", path, status);
+        }
+        return false;
+    }
+    return true;
+}
+
+/* Appends a space-separated option string to buf.  A space is appended only if
+ * the buffer is non-empty.  Aborts on buffer overflow.  Always null terminates
+ * the string.
+ * XXX: Use print_to_buffer.
+ */
+static void
+add_extra_option(char *buf, size_t bufsz, size_t *sofar, const char *fmt, ...)
+{
+    ssize_t len;
+    va_list ap;
+    if (*sofar > 0 && *sofar < bufsz)
+        buf[(*sofar)++] = ' '; /* Add a space. */
+
+    va_start(ap, fmt);
+    len = vsnprintf(buf + *sofar, bufsz - *sofar, fmt, ap);
+    va_end(ap);
+
+    if (len < 0 || (size_t)len >= bufsz) {
+        error("option string too long, buffer overflow");
+        die();
+    }
+    *sofar += len;
+    /* be paranoid: though usually many calls in a row and could delay until end */
+    buf[bufsz - 1] = '\0';
+}
+
+static bool
+read_tool_file(const char *toolname, const char *dr_root, char *client,
+               size_t client_size, char *ops, size_t ops_size, size_t *ops_sofar,
+               char *tool_ops, size_t tool_ops_size, size_t *tool_ops_sofar)
+{
+    FILE *f;
+    char config_file[MAXIMUM_PATH];
+    char line[MAXIMUM_PATH];
+    bool found_client = false;
+    const char *arch = IF_X64_ELSE("64", "32");
+    _snprintf(config_file, BUFFER_SIZE_ELEMENTS(config_file), "%s/tools/%s.drrun%s",
+              dr_root, toolname, arch);
+    NULL_TERMINATE_BUFFER(config_file);
+    info("reading tool config file %s", config_file);
+
+    f = fopen_utf8(config_file, "r");
+    if (f == NULL) {
+        error("cannot find tool config file %s", config_file);
+        return false;
+    }
+    while (fgets(line, BUFFER_SIZE_ELEMENTS(line), f) != NULL) {
+        ssize_t len;
+        NULL_TERMINATE_BUFFER(line);
+        len = strlen(line) - 1;
+        while (len >= 0 && (line[len] == '\n' || line[len] == '\r')) {
+            line[len] = '\0';
+            len--;
+        }
+        if (line[0] == '#') {
+            continue;
+        } else if (strstr(line, "CLIENT_REL=") == line) {
+            _snprintf(client, client_size, "%s/%s", dr_root,
+                      line + strlen("CLIENT_REL="));
+            client[client_size - 1] = '\0';
+            found_client = true;
+        } else if (strstr(line, IF_X64_ELSE("CLIENT64_REL=", "CLIENT32_REL=")) == line) {
+            _snprintf(client, client_size, "%s/%s", dr_root,
+                      line + strlen(IF_X64_ELSE("CLIENT64_REL=", "CLIENT32_REL=")));
+            client[client_size - 1] = '\0';
+            found_client = true;
+        } else if (strstr(line, "CLIENT_ABS=") == line) {
+            strncpy(client, line + strlen("CLIENT_ABS="), client_size);
+            found_client = true;
+        } else if (strstr(line, IF_X64_ELSE("CLIENT64_ABS=", "CLIENT32_ABS=")) == line) {
+            strncpy(client, line + strlen(IF_X64_ELSE("CLIENT64_ABS=", "CLIENT32_ABS=")),
+                    client_size);
+            found_client = true;
+        } else if (strstr(line, "DR_OP=") == line) {
+            if (strcmp(line, "DR_OP=") != 0) {
+                add_extra_option(ops, ops_size, ops_sofar, "\"%s\"",
+                                 line + strlen("DR_OP="));
+            }
+        } else if (strstr(line, "TOOL_OP=") == line) {
+            if (strcmp(line, "TOOL_OP=") != 0) {
+                add_extra_option(tool_ops, tool_ops_size, tool_ops_sofar, "\"%s\"",
+                                 line + strlen("TOOL_OP="));
+            }
+        } else if (strstr(line, "TOOL_OP_DR_PATH") == line) {
+            add_extra_option(tool_ops, tool_ops_size, tool_ops_sofar, "\"%s\"", dr_root);
+        } else if (strstr(line, "TOOL_OP_DR_BUNDLE=") == line) {
+            if (strcmp(line, "TOOL_OP_DR_BUNDLE=") != 0) {
+                add_extra_option(tool_ops, tool_ops_size, tool_ops_sofar, "%s `%s`",
+                                 line + strlen("TOOL_OP_DR_BUNDLE="), ops);
+            }
+        } else if (strstr(line, "USER_NOTICE=") == line) {
+            warn("%s", line + strlen("USER_NOTICE="));
+        } else if (line[0] != '\0') {
+            error("tool config file is malformed: unknown line %s", line);
+            return false;
+        }
+    }
+    fclose(f);
+    return found_client;
+}
+
+int
+main(int argc, char *targv[])
+{
+    char dr_root[MAXIMUM_PATH];
+    char extra_ops[MAX_OPTIONS_STRING];
+    size_t extra_ops_sofar = 0;
+
+    bool has_client = false;
+    char client_path[MAXIMUM_PATH];
+    client_id_t client_id = 0;
+    char client_ops[DR_MAX_OPTIONS_LENGTH];
+    size_t client_sofar = 0;
+
+    pid_t attach_pid = 0;
+    pid_t real_pid = 0;
+    pid_t detach_pid = 0;
+
+    bool use_debug = false;
+    int exitcode;
+
+    char buf[MAXIMUM_PATH];
+    char **argv;
+
+    drfront_status_t sc;
+    /* Convert to UTF-8 if necessary */
+    sc = drfront_convert_args((const char **)targv, &argv, argc);
+    if (sc != DRFRONT_SUCCESS)
+        fatal("failed to process args: %d", sc);
+
+    extra_ops[0] = '\0';
+    client_path[0]= '\0';
+    client_ops[0] = '\0';
+
+    /* default root: we assume this tool is in <root>/bin{32,64}/dr*.exe */
+    get_absolute_path(argv[0], buf, BUFFER_SIZE_ELEMENTS(buf));
+    NULL_TERMINATE_BUFFER(buf);
+    char *c = buf + strlen(buf) - 1;
+    while (*c != '\\' && *c != '/' && c > buf)
+        c--;
+    _snprintf(c + 1, BUFFER_SIZE_ELEMENTS(buf) - (c + 1 - buf), "..");
+    NULL_TERMINATE_BUFFER(buf);
+    get_absolute_path(buf, dr_root, BUFFER_SIZE_ELEMENTS(dr_root));
+    NULL_TERMINATE_BUFFER(dr_root);
+    info("default root: %s", dr_root);
+
+    /* we re-read the tool list if the root or platform change */
+    read_tool_list(dr_root);
+
+    /* parse command line */
+    for (int i = 1; i < argc; i++) {
+        /* params with no arg */
+        if (strcmp(argv[i], "-verbose") == 0 || strcmp(argv[i], "-v") == 0) {
+            verbose = true;
+            continue;
+        } else if (strcmp(argv[i], "-quiet") == 0) {
+            quiet = true;
+            continue;
+        } else if (strcmp(argv[i], "-debug") == 0) {
+            use_debug = true;
+            continue;
+        } else if (!strcmp(argv[i], "-version")) {
+#if defined(BUILD_NUMBER) && defined(VERSION_NUMBER)
+            printf(TOOLNAME " version %s -- build %d\n", STRINGIFY(VERSION_NUMBER),
+                   BUILD_NUMBER);
+#elif defined(BUILD_NUMBER)
+            printf(TOOLNAME " custom build %d -- %s\n", BUILD_NUMBER, __DATE__);
+#else
+            printf(TOOLNAME " custom build -- %s, %s\n", __DATE__, __TIME__);
+#endif
+            exit(0);
+        } else if (strcmp(argv[i], "-help") == 0 || strcmp(argv[i], "--help") == 0 ||
+                 strcmp(argv[i], "-h") == 0) {
+            usage(true, "" /* no error msg */);
+        } else {
+            if (strcmp(argv[i], "-attach") != 0 && strcmp(argv[i], "-detach") != 0 &&
+                strcmp(argv[i], "-process") != 0 &&
+                strcmp(argv[i], "-logdir") != 0 && strcmp(argv[i], "-ops") != 0 &&
+                strcmp(argv[i], "-c") != 0 && strcmp(argv[i], "-t") != 0) {
+                usage(false, "invalid arguments %s", argv[i]);
+            } else if (i == argc - 1) {
+                usage(false, "too few arguments to %s", argv[i]);
+            }
+        }
+
+        /* params with an arg */
+        if (strcmp(argv[i], "-attach") == 0) {
+            const char *pid_str = argv[++i];
+            pid_t pid = strtoul(pid_str, NULL, 10);
+            if (pid == ULONG_MAX)
+                usage(false, "-attach expects an integer pid");
+            if (pid <= 0)
+                usage(false, "-attach expects an valid pid");
+            attach_pid = pid;
+            continue;
+        } else if (strcmp(argv[i], "-process") == 0) {
+            const char *pid_str = argv[++i];
+            pid_t pid = strtoul(pid_str, NULL, 10);
+            if (pid == ULONG_MAX)
+                usage(false, "-process expects an integer pid");
+            if (pid <= 0)
+                usage(false, "-process expects an valid pid");
+            real_pid = pid;
+            continue;
+        } else if (strcmp(argv[i], "-detach") == 0) {
+            const char *pid_str = argv[++i];
+            pid_t pid = strtoul(pid_str, NULL, 10);
+            if (pid == ULONG_MAX)
+                usage(false, "-detach expects an integer pid");
+            if (pid <= 0)
+                usage(false, "-detach expects an valid pid");
+            detach_pid = pid;
+            continue;
+        } else if (strcmp(argv[i], "-logdir") == 0) {
+            /* Accept this for compatibility with the old drrun shell script. */
+            const char *dir = argv[++i];
+            if (!does_file_exist(dir))
+                usage(false, "-logdir %s does not exist", dir);
+            add_extra_option(extra_ops, BUFFER_SIZE_ELEMENTS(extra_ops), &extra_ops_sofar,
+                             "-logdir `%s`", dir);
+            continue;
+        } else if (strcmp(argv[i], "-ops") == 0) {
+            /* support repeating the option (i#477) */
+            add_extra_option(extra_ops, BUFFER_SIZE_ELEMENTS(extra_ops), &extra_ops_sofar,
+                             "%s", argv[++i]);
+            continue;
+        } else if (strcmp(argv[i], "-c") == 0 || strcmp(argv[i], "-t") == 0) {
+            const char *client = argv[++i];    
+            if (strcmp(argv[i - 1], "-t") == 0) {
+                if (!read_tool_file(client, dr_root, client_path,
+                                    BUFFER_SIZE_ELEMENTS(client_path), extra_ops,
+                                    BUFFER_SIZE_ELEMENTS(extra_ops), &extra_ops_sofar,
+                                    client_ops,
+                                    BUFFER_SIZE_ELEMENTS(client_ops),
+                                    &client_sofar))
+                    usage(false, "unknown %s tool \"%s\" requested",
+                            IF_X64_ELSE("64-bit", "32-bit/WOW64"), client);
+            } else {
+                _snprintf(client_path, BUFFER_SIZE_ELEMENTS(client_path), "%s",
+                  client);
+            }
+            while (++i < argc) {
+                add_extra_option(client_ops,
+                                 BUFFER_SIZE_ELEMENTS(client_ops), &client_sofar,
+                                 "\"%s\"", argv[i]);
+            }
+            has_client = true;
+        }
+    }
+    if(attach_pid == 0 && detach_pid == 0) {
+        usage(false, "must use -attach <pid> or -detach <pid>");
+    }
+    if(detach_pid != 0) {
+        drcct_detach_inject_ptrace(detach_pid, verbose);
+        goto cleanup;
+    }
+    if (real_pid == 0) {
+        real_pid = attach_pid;
+    }
+    char exe_str[MAXIMUM_PATH];
+    sprintf(exe_str, "/proc/%u/exe", attach_pid);
+    ssize_t size = readlink(exe_str, buf, BUFFER_SIZE_ELEMENTS(buf));
+    if (size > 0) {
+        if (size < BUFFER_SIZE_ELEMENTS(buf))
+            buf[size] = '\0';
+        else
+            NULL_TERMINATE_BUFFER(buf);
+    }
+    char* app_name = strdup(buf);
+
+    /* support running out of a debug build dir */
+    if (!use_debug &&
+        !check_dr_root(dr_root, false) &&
+        check_dr_root(dr_root, true)) {
+        info("debug build directory detected: switching to debug build");
+        use_debug = true;
+    }
+
+    dr_get_config_dir(false, true /*use temp*/, buf, BUFFER_SIZE_ELEMENTS(buf));
+    info("configuration directory is \"%s\"", buf);
+
+    char* process = strrchr(app_name, '/');
+    if(real_pid != attach_pid) {
+        if (!register_proc(process, real_pid, dr_root, use_debug, extra_ops))
+            goto error;
+        if (has_client) {
+            if (!register_client(process, real_pid, client_id, client_path, client_ops))
+                goto error;
+        }
+    }
+    
+    if (!register_proc(process, attach_pid, dr_root, use_debug, extra_ops))
+        goto error;
+    if (has_client) {
+        if (!register_client(process, attach_pid, client_id, client_path, client_ops))
+            goto error;
+    }
+
+    drcct_attach_inject_ptrace(attach_pid, process, verbose);
+    goto cleanup;
+error:
+    exitcode = 1;
+cleanup:
+    sc = drfront_cleanup_args(argv, argc);
+    if (sc != DRFRONT_SUCCESS)
+        fatal("failed to free memory for args: %d", sc);
+    return exitcode;
+}
-- 
2.29.0

